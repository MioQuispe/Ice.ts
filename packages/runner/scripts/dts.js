// packages/runner/scripts/build-dts.js
import { writeFileSync } from "node:fs"
import { resolve as pathResolve } from "node:path"
import { fileURLToPath } from "node:url"
import { generateDtsBundle } from "dts-bundle-generator"

const __filename = fileURLToPath(import.meta.url)
const __dirname = pathResolve(__filename, "..")

async function main() {
	const [dts] = generateDtsBundle(
		[
			{
				// ðŸ‘‰ your PUBLIC entry
				filePath: pathResolve(__dirname, "../tsup/index.d.ts"),
				// filePath: pathResolve(__dirname, "../src/index.ts"),

				// weâ€™ll write the file ourselves
				output: {
					noBanner: true,
					exportReferencedTypes: true, // pull in anything referenced by the public API
				},

				libraries: {
					// inline the problematic deps so they NEVER appear as imports in the final d.ts
					inlinedLibraries: [
						"@dfinity/agent",
						"@dfinity/principal",
						"@dfinity/candid",
                        "@standard-schema/spec",
						// add others here if they leak into TaskCtx / ICEConfig / whatever
					],
					importedLibraries: [],
					referencedLibraries: [],
				},
			},
		],
		{
			// so it understands your monorepo layout, paths, etc.
			preferredConfigPath: pathResolve(__dirname, "../tsconfig.json"),
		},
	)

	const header =
		"// DO NOT EDIT BY HAND. Generated by scripts/build-dts.js\n\n"
	const outPath = pathResolve(__dirname, "../dist/index.d.ts")
	writeFileSync(outPath, header + dts + "\n", "utf8")
	console.log("Wrote", outPath)
}

main().catch((err) => {
	console.error(err)
	process.exit(1)
})
