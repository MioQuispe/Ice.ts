import { Effect } from "effect"
import { FileSystem, Path } from "@effect/platform"
import { ICEConfigService } from "../services/iceConfig.js"
import { IceDir } from "../services/iceDir.js"
import { runTask } from "../tasks/run.js"
import { filterNodes } from "../tasks/lib.js"
import { CanisterScopeSimple, Tags } from "../builders/lib.js"
import type { Task, Scope } from "../types/types.js"
import { MotokoCanisterConfig } from "../builders/motoko.js"
import { RustCanisterConfig } from "../builders/rust.js"
import { CustomCanisterConfig } from "../builders/custom.js"
import { RemoteCanisterConfig } from "../builders/remote.js"

export const generateIceEnv = () =>
	Effect.gen(function* () {
		const fs = yield* FileSystem.FileSystem
		const path = yield* Path.Path
		const iceDir = yield* IceDir
		const { tasks: taskTree } = yield* ICEConfigService

		// 1. Find all canister scopes
		const canisterScopes = (yield* filterNodes(
			taskTree,
			(node) =>
				node._tag === "scope" && node.tags.includes(Tags.CANISTER),
		)) as Array<{ node: CanisterScopeSimple; path: string[] }>

		const imports: string[] = []
		const mappings: string[] = []
		let counter = 1

		for (const { node: scope, path: scopePath } of canisterScopes) {
			const canisterName = scopePath[scopePath.length - 1]!
			const configTask = scope.children["config"]
			if (!configTask) continue

			// 2. Run config task to get the resolved config object (src, candid path, etc.)
			// We pass empty args {} as config tasks typically don't take CLI args
			const config = yield* runTask(configTask, {})

			const serviceName = `Service${counter++}`
			// Import path relative to .ice/ice-env.d.ts
			const didTsImportPath = `./canisters/${canisterName}/${canisterName}.did.ts`

			// 3. Verify the generated .did.ts exists
			const absDidTsPath = path.join(
				iceDir.path,
				"canisters",
				canisterName,
				`${canisterName}.did.ts`,
			)
			const exists = yield* fs.exists(absDidTsPath)

			if (!exists) continue

			// 4. Add import statement
			imports.push(
				`import type { _SERVICE as ${serviceName} } from "${didTsImportPath}"`,
			)

			// 5. Determine the lookup key based on builder type
			let key: string | undefined
			if (scope.tags.includes(Tags.MOTOKO)) {
				// Motoko uses the 'src' path as the key
				key = (config as MotokoCanisterConfig).src
			} else if (
				scope.tags.includes(Tags.RUST) ||
				scope.tags.includes(Tags.CUSTOM) ||
				scope.tags.includes(Tags.REMOTE)
			) {
				// Others use the 'candid' path as the key
				key = (
					config as
						| RustCanisterConfig
						| CustomCanisterConfig
						| RemoteCanisterConfig
				).candid
			}

			// 6. Add mapping entry
			if (key) {
				mappings.push(`    "${key}": ${serviceName}`)
			}
		}

		// 7. Generate and write the file
		const content = `// .ice/ice-env.d.ts
// This file is automatically generated by ICE.
// Do not edit it manually.

${imports.join("\n")}

declare global {
  interface IceCanisterPaths {
${mappings.join("\n")}
  }
}
`
		yield* fs.writeFileString(
			path.join(iceDir.path, "ice-env.d.ts"),
			content,
		)
		yield* Effect.logDebug("Generated ice-env.d.ts")
	})
